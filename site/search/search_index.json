{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Liquid","text":"<p>A Python implementation of Liquid, the safe customer-facing template language for flexible web apps.</p> <p>Info</p> <p>See https://jg-rp.github.io/liquid/ for guides, tag and filter references and extra, non-standard plugins.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python Liquid using Pipenv:</p> <pre><code>$ pipenv install -u python-liquid\n</code></pre> <p>Or pip:</p> <pre><code>$ pip install python-liquid\n</code></pre> <p>Or from conda-forge:</p> <pre><code>$ conda install -c conda-forge python-liquid\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Render a template string by creating a <code>Template</code> and calling its <code>render()</code> method.</p> <pre><code>from liquid import Template\ntemplate = Template(\"Hello, {{ you }}!\")\nprint(template.render(you=\"World\"))  # Hello, World!\nprint(template.render(you=\"Liquid\"))  # Hello, Liquid!\n</code></pre> <p>Keyword arguments passed to render() are available as variables for templates to use in Liquid expressions.</p> <pre><code>from liquid import Template\ntemplate = Template(\n\"{% for person in people %}\"\n\"Hello, {{ person.name }}!\\n\"\n\"{% endfor %}\"\n)\ndata = {\n\"people\": [\n{\"name\": \"John\"},\n{\"name\": \"Sally\"},\n]\n}\nprint(template.render(**data))\n# Hello, John!\n# Hello, Sally!\n</code></pre>"},{"location":"#whats-next","title":"What's next?","text":"<p>Learn how to configure a Liquid environment and load templates from a file system or database.</p>"},{"location":"analysis/","title":"Template Analysis","text":""},{"location":"analysis/#liquid.static_analysis.TemplateAnalysis","title":"TemplateAnalysis","text":"<pre><code>TemplateAnalysis(\n*,\nvariables: Refs,\nlocal_variables: Refs,\nglobal_variables: Refs,\nfailed_visits: NameRefs,\nunloadable_partials: NameRefs,\nfilters: NameRefs,\ntags: NameRefs\n) -&gt; None\n</code></pre> <p>The result of analyzing a template using <code>BoundTemplate.analyze</code>.</p> <p>Each of the following properties is a dictionary mapping variable, tag or filter names to a list of tuples. Each tuple holds the location of a reference to the name as (template name, line number). If a name is referenced multiple times, it will appear multiple times in the list. If a name is referenced before it is \"assigned\", it will appear in <code>local_variables</code> and <code>global_variables</code>.</p> ATTRIBUTE DESCRIPTION <code>variables</code> <p>All referenced variables, whether they are in scope or not. Including references to names such as <code>forloop</code> from the <code>for</code> tag.</p> <p> </p> <code>local_variables</code> <p>Template variables that are added to the template local scope, whether they are subsequently used or not.</p> <p> </p> <code>global_variables</code> <p>Template variables that, on the given line number and \"file\", are out of scope or are assumed to be \"global\". That is, expected to be included by the application developer rather than a template author.</p> <p> </p> <code>failed_visits</code> <p>Names of AST <code>Node</code> and <code>Expression</code> objects that could not be visited, probably because they do not implement a <code>children</code> method.</p> <p> </p> <code>unloadable_partials</code> <p>Names or identifiers of partial templates that could not be loaded. This will be empty if <code>follow_partials</code> is <code>False</code>.</p> <p> </p> <code>filters</code> <p>All filters found during static analysis.</p> <p> </p> <code>tags</code> <p>All tags found during static analysis.</p> <p> </p>"},{"location":"analysis/#liquid.static_analysis.ContextualTemplateAnalysis","title":"ContextualTemplateAnalysis","text":"<pre><code>ContextualTemplateAnalysis(\n*,\nall_variables: Dict[str, int],\nlocal_variables: Dict[str, int],\nundefined_variables: Dict[str, int],\nfilters: Dict[str, int]\n) -&gt; None\n</code></pre> <p>The result of analyzing a template using <code>BoundTemplate.analyze_with_context</code>.</p> <p>Each of the following properties is a dictionary mapping variable or filter names to the number of times that variable was referenced.</p> ATTRIBUTE DESCRIPTION <code>all_variables</code> <p>All variables references along a path through the template's syntax tree.</p> <p> </p> <code>local_variables</code> <p>The names of variables assigned using the built-in <code>assign</code> <code>capture</code>, <code>increment</code> or <code>decrement</code> tags, or any custom tag that uses <code>Context.assign()</code>.</p> <p> </p> <code>undefined_variables</code> <p>The names of variables that could not be resolved. If a name is referenced before it is assigned, it will appear in <code>undefined</code> and <code>assigns</code>.</p> <p> </p> <code>filters</code> <p>Names of filters found during contextual analysis.</p> <p> </p>"},{"location":"analysis/#liquid.analyze_tags.TagAnalysis","title":"TagAnalysis","text":"<pre><code>TagAnalysis(\n*,\nenv: Environment,\nname: str,\ntokens: List[Token],\ninner_tags: Optional[InnerTagMap] = None\n) -&gt; None\n</code></pre> <p>The result of analyzing a template's tags with <code>Environment.analyze_tags()</code>.</p> <p>Each of the following properties maps tag names to a list of their locations. Locations are (template_name, line_number) tuples.</p> <p>Note that <code>raw</code> tags are not included at all. The lexer converts them to text tokens before we get a chance to analyze them.</p> <p>Also be aware that reported <code>unexpected_tags</code> don't handle the possibility of an \"inner\" tag appearing in a partial template (using <code>{% include %}</code>), where appropriate enclosing block tags are in the parent template.</p> ATTRIBUTE DESCRIPTION <code>all_tags</code> <p>A mapping of all tags to their locations. Includes \"end\", \"inner\" and unknown tags.</p> <p> </p> <code>tags</code> <p>A mapping of tag names to their locations. Excludes \"end\" and \"inner\" tags.</p> <p> </p> <code>unclosed_tags</code> <p>Block tags that don't have a matching \"end\" tag.</p> <p> </p> <code>unexpected_tags</code> <p>Inner tags that are not properly enclosed by appropriate block tags. For example, an <code>{% else %}</code> that is not enclosed by a <code>{% for %}</code> or <code>{% unless %}</code> block.</p> <p> </p> <code>unknown_tags</code> <p>Tags that are unknown to the environment.</p> <p> </p>"},{"location":"api/","title":"Rendering Templates","text":""},{"location":"api/#liquid.Environment","title":"Environment","text":"<pre><code>Environment(\ntag_start_string: str = \"{%\",\ntag_end_string: str = \"%}\",\nstatement_start_string: str = \"{{\",\nstatement_end_string: str = \"}}\",\nstrip_tags: bool = False,\ntolerance: Mode = Mode.STRICT,\nloader: Optional[loaders.BaseLoader] = None,\nundefined: Type[Undefined] = Undefined,\nstrict_filters: bool = True,\nautoescape: bool = False,\nauto_reload: bool = True,\ncache_size: int = 300,\nglobals: Optional[Mapping[str, object]] = None,\ntemplate_comments: bool = False,\ncomment_start_string: str = \"{#\",\ncomment_end_string: str = \"#}\",\nexpression_cache_size: int = 0,\n)\n</code></pre> <p>Shared configuration from which templates can be loaded and parsed.</p> <p>An <code>Environment</code> is where you might register custom tags and filters, or store global context variables that should be included with every template.</p> PARAMETER DESCRIPTION <code>tag_start_string</code> <p>The sequence of characters indicating the start of a liquid tag.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{%'</code> </p> <code>tag_end_string</code> <p>The sequence of characters indicating the end of a liquid tag.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'%}'</code> </p> <code>statement_start_string</code> <p>The sequence of characters indicating the start of an output statement.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{{'</code> </p> <code>statement_end_string</code> <p>The sequence of characters indicating the end of an output statement.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'}}'</code> </p> <code>template_comments</code> <p>If <code>True</code>, enable template comments. Where, by default, anything between <code>{#</code> and <code>#}</code> is considered a comment. <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>comment_start_string</code> <p>The sequence of characters indicating the start of a comment. <code>comment_start_string</code> to have any effect.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{#'</code> </p> <code>comment_end_string</code> <p>The sequence of characters indicating the end of a comment. <code>comment_end_string</code> to have any effect.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'#}'</code> </p> <code>tolerance</code> <p>Indicates how tolerant to be of errors. Must be one of <code>Mode.LAX</code>, <code>Mode.WARN</code> or <code>Mode.STRICT</code>.</p> <p> TYPE: <code>Mode</code> DEFAULT: <code>Mode.STRICT</code> </p> <code>loader</code> <p>A template loader. If you want to use the builtin \"render\" or \"include\" tags, a loader must be configured. <code>liquid.loaders.DictLoader</code>.</p> <p> TYPE: <code>Optional[loaders.BaseLoader]</code> DEFAULT: <code>None</code> </p> <code>undefined</code> <p>A subclass of <code>Undefined</code> that represents undefined values. Could be one of the built-in undefined types, <code>Undefined</code>, <code>DebugUndefined</code> or <code>StrictUndefined</code>. undefined type that silently ignores undefined values.</p> <p> TYPE: <code>Type[Undefined]</code> DEFAULT: <code>Undefined</code> </p> <code>strict_filters</code> <p>If <code>True</code>, will raise an exception upon finding an undefined filter. Otherwise undefined filters are silently ignored. Defaults to <code>True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>autoescape</code> <p>If <code>True</code>, all context values will be HTML-escaped before output unless they've been explicitly marked as \"safe\". Requires the package Markupsafe.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>auto_reload</code> <p>If <code>True</code>, loaders that have an <code>uptodate</code> callable will reload template source data automatically. For deployments where template sources don't change between service reloads, setting auto_reload to <code>False</code> can yield an increase in performance by avoiding calls to <code>uptodate</code>. `.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>cache_size</code> <p>The capacity of the template cache in number of templates. . If <code>cache_size</code> is <code>None</code> or less than <code>1</code>, it has the effect of setting <code>auto_reload</code> to <code>False</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p> <code>expression_cache_size</code> <p>The capacity of each of the common expression caches. `, disabling expression caching.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>globals</code> <p>An optional mapping that will be added to the context of any template loaded from this environment.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>context_depth_limit</code> <p>Class attribute.The maximum number of times a render context can be extended or wrapped before a <code>ContextDepthError</code> is raised.</p> <p> TYPE: <code>ClassVar[int]</code> </p> <code>local_namespace_limit</code> <p>Class attribute. The maximum number of bytes (according to sys.getsizeof) allowed in a template's local namespace, per render, before a <code>LocalNamespaceLimitError</code> exception is raised. Note that we only count the size of the local namespace values, not its keys.</p> <p> TYPE: <code>ClassVar[Optional[int]]</code> </p> <code>loop_iteration_limit</code> <p>Class attribute. The maximum number of loop iterations allowed before a  <code>liquid.exceptions.LoopIterationLimitError</code> is raised.</p> <p> TYPE: <code>ClassVar[Optional[int]]</code> </p> <code>output_stream_limit</code> <p>Class attribute. The maximum number of bytes that can be written to a template's output stream, per render, before an <code>OutputStreamLimitError</code> exception is raised.</p> <p> TYPE: <code>ClassVar[Optional[int]]</code> </p> <code>undefined</code> <p>The undefined type. When an identifier can not be resolved, an instance of <code>undefined</code> is returned.</p> <p> </p> <code>strict_filters</code> <p>Indicates if an undefined filter should raise an exception or be ignored.</p> <p> </p> <code>autoescape</code> <p>Indicates if auto-escape is enabled.</p> <p> </p> <code>tags</code> <p>A dictionary mapping tag names to <code>liquid.tag.Tag</code> instances.</p> <p> TYPE: <code>Dict[str, Tag]</code> </p> <code>filters</code> <p>A dictionary mapping filter names to callable objects implementing a filter's behavior.</p> <p> TYPE: <code>Dict[str, Callable[..., Any]]</code> </p> <code>mode</code> <p>The current tolerance mode.</p> <p> </p> <code>cache</code> <p>The template cache.</p> <p> TYPE: <code>Optional[MutableMapping[Any, Any]]</code> </p> <code>auto_reload</code> <p>Indicates if automatic reloading of templates is enabled.</p> <p> </p> <code>template_class</code> <p><code>Environment.get_template</code> and <code>Environment.from_string</code> return an instance of :attr:<code>Environment.template_class</code>. <code>liquid.template.BoundTemplate</code>.</p> <p> </p> <code>globals</code> <p>A dictionary of variables that will be added to the context of every template rendered from the environment.</p> <p> TYPE: <code>Mapping[str, object]</code> </p>"},{"location":"api/#liquid.environment.Environment.add_filter","title":"add_filter","text":"<pre><code>add_filter(name: str, func: Callable[..., Any]) -&gt; None\n</code></pre> <p>Register a filter function with the environment.</p> PARAMETER DESCRIPTION <code>name</code> <p>The filter's name. Does not need to match the function name. This is what you'll use to apply the filter to an expression in a liquid template.</p> <p> TYPE: <code>str</code> </p> <code>func</code> <p>Any callable that accepts at least one argument, the result of the expression the filter is applied to. If the filter needs access to the environment or render context, you probably want to make <code>func</code> a class that inherits from <code>liquid.filter.Filter</code>, and override the <code>__call__</code> method. All builtin filters are implemented in this way.</p> <p> TYPE: <code>Callable[..., Any]</code> </p>"},{"location":"api/#liquid.environment.Environment.add_tag","title":"add_tag","text":"<pre><code>add_tag(tag: Type[Tag]) -&gt; None\n</code></pre> <p>Register a liquid tag with the environment.</p> <p>Built-in tags are registered for you automatically with every new <code>Environment</code>.</p> PARAMETER DESCRIPTION <code>tag</code> <p>The tag to register.</p> <p> TYPE: <code>Type[Tag]</code> </p>"},{"location":"api/#liquid.environment.Environment.analyze_tags","title":"analyze_tags","text":"<pre><code>analyze_tags(\nname: str,\n*,\ncontext: Optional[Context] = None,\ninner_tags: Optional[InnerTagMap] = None,\n**kwargs: str\n) -&gt; TagAnalysis\n</code></pre> <p>Audit template tags without parsing source text into an abstract syntax tree.</p> <p>This is useful for identifying unknown, misplaced and unbalanced tags in a template's source text. See also <code>liquid.template.BoundTemplate.analyze</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The template's name or identifier, as you would use with <code>Environment.get_template</code>. Use <code>Environment.analyze_tags_from_string</code> to audit tags in template text without using a template loader.</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>An optional render context the loader might use to modify the template search space. If given, uses <code>liquid.loaders.BaseLoader.get_source_with_context</code> from the current loader.</p> <p> TYPE: <code>Optional[Context]</code> DEFAULT: <code>None</code> </p> <code>inner_tags</code> <p>A mapping of block tags to a list of allowed \"inner\" tags for the block. For example, <code>{% if %}</code> blocks are allowed to contain <code>{% elsif %}</code> and <code>{% else %}</code> tags.</p> <p> TYPE: <code>Optional[InnerTagMap]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Loader context.</p> <p> TYPE: <code>str</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/#liquid.environment.Environment.analyze_tags_async","title":"analyze_tags_async  <code>async</code>","text":"<pre><code>analyze_tags_async(\nname: str,\n*,\ncontext: Optional[Context] = None,\ninner_tags: Optional[InnerTagMap] = None,\n**kwargs: str\n) -&gt; TagAnalysis\n</code></pre> <p>An async version of <code>Environment.analyze_tags</code>.</p>"},{"location":"api/#liquid.environment.Environment.analyze_tags_from_string","title":"analyze_tags_from_string","text":"<pre><code>analyze_tags_from_string(\nsource: str,\nname: str = \"&lt;string&gt;\",\n*,\ninner_tags: Optional[InnerTagMap] = None\n) -&gt; TagAnalysis\n</code></pre> <p>Analyze tags in template source text.</p> <p>Unlike template static or contextual analysis, a tag audit does not parse the template source text into an AST, nor does it attempt to load partial templates from <code>{% include %}</code> or <code>{% render %}</code> tags.</p> PARAMETER DESCRIPTION <code>source</code> <p>The source text of the template.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>A name or identifier for the template.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'&lt;string&gt;'</code> </p> <code>inner_tags</code> <p>A mapping of block tags to a list of allowed \"inner\" tags for the block. For example, <code>{% if %}</code> blocks are allowed to contain <code>{% elsif %}</code> and <code>{% else %}</code> tags.</p> <p> TYPE: <code>Optional[InnerTagMap]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#liquid.environment.Environment.error","title":"error","text":"<pre><code>error(\nexc: Union[Type[Error], Error],\nmsg: Optional[str] = None,\nlinenum: Optional[int] = None,\n) -&gt; None\n</code></pre> <p>Raise, warn or ignore the given exception according to the current mode.</p>"},{"location":"api/#liquid.environment.Environment.from_string","title":"from_string","text":"<pre><code>from_string(\nsource: str,\nname: str = \"\",\npath: Optional[Union[str, Path]] = None,\nglobals: Optional[Mapping[str, object]] = None,\nmatter: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>Parse the given string as a liquid template.</p> PARAMETER DESCRIPTION <code>source</code> <p>The liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Optional name of the template. Available as <code>Template.name</code>.  empty string.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>path</code> <p>Optional path or identifier to the origin of the template. Defaults to <code>None</code>.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>globals</code> <p>An optional mapping of context variables made available every time the resulting template is rendered.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>matter</code> <p>Optional mapping containing variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#liquid.environment.Environment.get_template","title":"get_template","text":"<pre><code>get_template(\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>Load and parse a template using the configured loader.</p> PARAMETER DESCRIPTION <code>name</code> <p>The template's name. The loader is responsible for interpreting the name. It could be the name of a file or some other identifier.</p> <p> TYPE: <code>str</code> </p> <code>globals</code> <p>A mapping of context variables made available every time the resulting template is rendered.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>TemplateNotFound`</code> <p>if a template with the given name can not be found.</p>"},{"location":"api/#liquid.environment.Environment.get_template_async","title":"get_template_async  <code>async</code>","text":"<pre><code>get_template_async(\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>get_template</code>.</p>"},{"location":"api/#liquid.environment.Environment.get_template_with_args","title":"get_template_with_args","text":"<pre><code>get_template_with_args(\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n**kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>Load and parse a template with arbitrary loader arguments.</p> <p>This method bypasses the environment's template cache. You should use a caching loader instead when the loader required extra keyword arguments.</p>"},{"location":"api/#liquid.environment.Environment.get_template_with_args_async","title":"get_template_with_args_async  <code>async</code>","text":"<pre><code>get_template_with_args_async(\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n**kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>get_template_with_args</code>.</p>"},{"location":"api/#liquid.environment.Environment.get_template_with_context","title":"get_template_with_context","text":"<pre><code>get_template_with_context(\ncontext: Context, name: str, **kwargs: str\n) -&gt; BoundTemplate\n</code></pre> <p>Load and parse a template with reference to a render context.</p> <p>This method bypasses the environment's template cache. You should consider using a caching loader.</p>"},{"location":"api/#liquid.environment.Environment.get_template_with_context_async","title":"get_template_with_context_async  <code>async</code>","text":"<pre><code>get_template_with_context_async(\ncontext: Context, name: str, **kwargs: str\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>get_template_with_context</code>.</p>"},{"location":"api/#liquid.environment.Environment.make_globals","title":"make_globals","text":"<pre><code>make_globals(\nglobals: Optional[Mapping[str, object]] = None\n) -&gt; Dict[str, object]\n</code></pre> <p>Combine environment globals with template globals.</p>"},{"location":"api/#liquid.environment.Environment.parse","title":"parse","text":"<pre><code>parse(source: str) -&gt; ast.ParseTree\n</code></pre> <p>Parse <code>source</code> as a liquid template.</p> <p>More often than not you'll want to use <code>Environment.from_string</code> instead.</p>"},{"location":"api/#liquid.environment.Environment.set_expression_cache_size","title":"set_expression_cache_size","text":"<pre><code>set_expression_cache_size(maxsize: int = 0) -&gt; None\n</code></pre> <p>Create or replace cached versions of the common expression parsers.</p> <p>If <code>maxsize</code> is less than <code>1</code>, no expression caching will happen.</p> PARAMETER DESCRIPTION <code>maxsize</code> <p>The maximum size of each expression cache.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p>"},{"location":"api/#liquid.environment.Environment.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer() -&gt; Callable[[str], Iterator[Token]]\n</code></pre> <p>Return a tokenizer for this environment.</p>"},{"location":"api/#liquid.Template","title":"Template","text":"<pre><code>Template(\nsource: str,\ntag_start_string: str = \"{%\",\ntag_end_string: str = \"%}\",\nstatement_start_string: str = \"{{\",\nstatement_end_string: str = \"}}\",\nstrip_tags: bool = False,\ntolerance: Mode = Mode.STRICT,\nundefined: Type[Undefined] = Undefined,\nstrict_filters: bool = True,\nautoescape: bool = False,\nauto_reload: bool = True,\ncache_size: int = 300,\nglobals: Optional[Mapping[str, object]] = None,\ntemplate_comments: bool = False,\ncomment_start_string: str = \"{#\",\ncomment_end_string: str = \"#}\",\nexpression_cache_size: int = 0,\n) -&gt; BoundTemplate\n</code></pre> <p>Parse a template, automatically creating an <code>Environment</code> to bind it to.</p> <p>Other than <code>source</code>, all arguments are passed to the implicit <code>Environment</code>, which might have been cached from previous calls to <code>Template</code>.</p> PARAMETER DESCRIPTION <code>source</code> <p>A Liquid template source string.</p> <p> TYPE: <code>str</code> </p> <code>tag_start_string</code> <p>The sequence of characters indicating the start of a liquid tag.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{%'</code> </p> <code>tag_end_string</code> <p>The sequence of characters indicating the end of a liquid tag.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'%}'</code> </p> <code>statement_start_string</code> <p>The sequence of characters indicating the start of an output statement.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{{'</code> </p> <code>statement_end_string</code> <p>The sequence of characters indicating the end of an output statement.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'}}'</code> </p> <code>template_comments</code> <p>If <code>True</code>, enable template comments. Where, by default, anything between <code>{#</code> and <code>#}</code> is considered a comment.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>comment_start_string</code> <p>The sequence of characters indicating the start of a comment. <code>comment_start_string</code> to have any effect.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{#'</code> </p> <code>comment_end_string</code> <p>The sequence of characters indicating the end of a comment. <code>template_comments</code> must be <code>True</code> for <code>comment_end_string</code> to have any effect.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'#}'</code> </p> <code>tolerance</code> <p>Indicates how tolerant to be of errors. Must be one of <code>Mode.LAX</code>, <code>Mode.WARN</code> or <code>Mode.STRICT</code>.</p> <p> TYPE: <code>Mode</code> DEFAULT: <code>Mode.STRICT</code> </p> <code>undefined</code> <p>A subclass of <code>Undefined</code> that represents undefined values. Could be one of the built-in undefined types, <code>Undefined</code>, <code>DebugUndefined</code> or <code>StrictUndefined</code>. ignores undefined values.</p> <p> TYPE: <code>Type[Undefined]</code> DEFAULT: <code>Undefined</code> </p> <code>strict_filters</code> <p>If <code>True</code>, will raise an exception upon finding an undefined filter. Otherwise undefined filters are silently ignored. <code>True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>autoescape</code> <p>If <code>True</code>, all context values will be HTML-escaped before output unless they've been explicitly marked as \"safe\". Requires the package Markupsafe.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>auto_reload</code> <p>If <code>True</code>, loaders that have an <code>uptodate</code> callable will reload template source data automatically. For deployments where template sources don't change between service reloads, setting auto_reload to <code>False</code> can yield an increase in performance by avoiding calls to <code>uptodate</code>. Defaults to <code>True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>cache_size</code> <p>The capacity of the template cache in number of templates. Defaults to 300. If <code>cache_size</code> is <code>None</code> or less than <code>1</code>, it has the effect of setting <code>auto_reload</code> to <code>False</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p> <code>expression_cache_size</code> <p>The capacity of each of the common expression caches. `, disabling expression caching.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>globals</code> <p>An optional mapping that will be added to the context of any template loaded from this environment.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#liquid.BoundTemplate","title":"BoundTemplate","text":"<pre><code>BoundTemplate(\nenv: Environment,\nparse_tree: ParseTree,\nname: str = \"\",\npath: Optional[Union[str, Path]] = None,\nglobals: Optional[Dict[str, object]] = None,\nmatter: Optional[Mapping[str, object]] = None,\nuptodate: UpToDate = None,\n)\n</code></pre> <p>A liquid template that has been parsed and is bound to a <code>liquid.Environment</code>.</p> <p>You probably don't want to instantiate <code>BoundTemplate</code> directly. Use <code>liquid.Environment.from_string</code> or <code>liquid.Environment.get_template</code> instead.</p> PARAMETER DESCRIPTION <code>env</code> <p>The environment this template is bound to.</p> <p> TYPE: <code>Environment</code> </p> <code>parse_tree</code> <p>The parse tree representing this template.</p> <p> TYPE: <code>ParseTree</code> </p> <code>name</code> <p>Optional name of the template. Defaults to an empty string.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>path</code> <p>Optional origin path or identifier for the template.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>globals</code> <p>An optional mapping of context variables made available every time the resulting template is rendered. Defaults to <code>None</code>.</p> <p> TYPE: <code>Optional[Dict[str, object]]</code> DEFAULT: <code>None</code> </p> <code>matter</code> <p>Optional mapping containing variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>uptodate</code> <p>Optional callable that will return <code>True</code> if the template is up to date, or <code>False</code> if it needs to be reloaded. Defaults to <code>None</code>.</p> <p> TYPE: <code>UpToDate</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#liquid.template.BoundTemplate.is_up_to_date","title":"is_up_to_date  <code>property</code>","text":"<pre><code>is_up_to_date: bool\n</code></pre> <p><code>False</code> if the template has bee modified, <code>True</code> otherwise.</p>"},{"location":"api/#liquid.template.BoundTemplate.analyze","title":"analyze","text":"<pre><code>analyze(\nfollow_partials: bool = True,\nraise_for_failures: bool = True,\n) -&gt; TemplateAnalysis\n</code></pre> <p>Statically analyze this template and any included/rendered templates.</p> PARAMETER DESCRIPTION <code>follow_partials</code> <p>If <code>True</code>, we will try to load partial templates and analyze those templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>raise_for_failures</code> <p>If <code>True</code>, will raise an exception if an <code>ast.Node</code> or <code>expression.Expression</code> does not define a <code>children()</code> method, or if a partial template can not be loaded. When <code>False</code>, no exception is raised and a mapping of failed nodes and expressions is available as the <code>failed_visits</code> property. A mapping of unloadable partial templates is stored in the <code>unloadable_partials</code> property.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"api/#liquid.template.BoundTemplate.analyze_async","title":"analyze_async  <code>async</code>","text":"<pre><code>analyze_async(\nfollow_partials: bool = True,\nraise_for_failures: bool = True,\n) -&gt; TemplateAnalysis\n</code></pre> <p>An async version of <code>analyze</code>.</p>"},{"location":"api/#liquid.template.BoundTemplate.analyze_with_context","title":"analyze_with_context","text":"<pre><code>analyze_with_context(\n*args: Any, **kwargs: Any\n) -&gt; ContextualTemplateAnalysis\n</code></pre> <p>Analyze a path through this template's syntax tree given some context data.</p> <p>Unlike <code>analyze</code>, this form of template analysis does perform a render, capturing template variables as we go.</p> <p>Python Liquid does not currently support template introspection from within a render context or <code>Expression</code> object. Meaning line numbers and template names are not available. Only variable names are reported along with the number of times they were referenced.</p> <p>It's also, using this method, not currently possible to detect names added to a block's scope. For example, <code>forloop.index</code> will be included in the results object if referenced within a <code>for</code> loop block.</p> <p>Accepts the same arguments as <code>render</code>.</p>"},{"location":"api/#liquid.template.BoundTemplate.analyze_with_context_async","title":"analyze_with_context_async  <code>async</code>","text":"<pre><code>analyze_with_context_async(\n*args: Any, **kwargs: Any\n) -&gt; ContextualTemplateAnalysis\n</code></pre> <p>An async version of <code>analyze_with_context</code>.</p>"},{"location":"api/#liquid.template.BoundTemplate.is_up_to_date_async","title":"is_up_to_date_async  <code>async</code>","text":"<pre><code>is_up_to_date_async() -&gt; bool\n</code></pre> <p>An async version of the <code>is_up_to_date</code> property.</p> <p>If <code>template.uptodate</code> is a coroutine, it wil be awaited. Otherwise it will be called just like <code>is_up_to_date</code></p>"},{"location":"api/#liquid.template.BoundTemplate.make_globals","title":"make_globals","text":"<pre><code>make_globals(\nrender_args: Mapping[str, object]\n) -&gt; Mapping[str, object]\n</code></pre> <p>Return a mapping including render arguments and template globals.</p>"},{"location":"api/#liquid.template.BoundTemplate.make_partial_namespace","title":"make_partial_namespace","text":"<pre><code>make_partial_namespace(\npartial: bool, render_args: Mapping[str, object]\n) -&gt; Mapping[str, object]\n</code></pre> <p>Return a namespace dictionary.</p> <p>This is used by <code>render_with_context</code> to extend an existing context.</p>"},{"location":"api/#liquid.template.BoundTemplate.render","title":"render","text":"<pre><code>render(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Render the template with <code>args</code> and <code>kwargs</code> included in the render context.</p> <p>Accepts the same arguments as the <code>dict</code> constructor.</p>"},{"location":"api/#liquid.template.BoundTemplate.render_async","title":"render_async  <code>async</code>","text":"<pre><code>render_async(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>An async version of <code>liquid.template.BoundTemplate.render</code>.</p>"},{"location":"api/#liquid.template.BoundTemplate.render_with_context","title":"render_with_context","text":"<pre><code>render_with_context(\ncontext: Context,\nbuffer: TextIO,\n*args: Any,\npartial: bool = False,\nblock_scope: bool = False,\n**kwargs: Any\n) -&gt; None\n</code></pre> <p>Render the template using an existing context and output buffer.</p> PARAMETER DESCRIPTION <code>context</code> <p>A render context.</p> <p> TYPE: <code>Context</code> </p> <code>buffer</code> <p>File-like object to which rendered text is written.</p> <p> TYPE: <code>TextIO</code> </p> <code>partial</code> <p>If <code>True</code>, indicates that the current template has been included using either a \"render\" or \"include\" tag. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>block_scope</code> <p>If <code>True</code>, indicates that assigns, breaks and continues from this template will not leak into the parent context. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>args</code> <p>Passed to the <code>dict</code> constructor. The resulting dictionary is added to the render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Passed to the <code>dict</code> constructor. The resulting dictionary is added to the render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/#liquid.template.BoundTemplate.render_with_context_async","title":"render_with_context_async  <code>async</code>","text":"<pre><code>render_with_context_async(\ncontext: Context,\nbuffer: TextIO,\n*args: Any,\npartial: bool = False,\nblock_scope: bool = False,\n**kwargs: Any\n) -&gt; None\n</code></pre> <p>An async version of <code>render_with_context</code>.</p>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#liquid.exceptions.Error","title":"Error","text":"<pre><code>Error(\n*args: object,\nlinenum: Optional[int] = None,\nfilename: Optional[Union[str, Path]] = None\n)\n</code></pre> <p>         Bases: <code>Exception</code></p> <p>Base class for all Liquid exceptions.</p>"},{"location":"exceptions/#liquid.exceptions.Error.message","title":"message  <code>property</code>","text":"<pre><code>message: object\n</code></pre> <p>The exception's error message if one was given.</p>"},{"location":"exceptions/#liquid.exceptions.Error.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the template that raised this exception.</p> <p>An empty string is return if a name is not available.</p>"},{"location":"exceptions/#liquid.exceptions.LiquidSyntaxError","title":"LiquidSyntaxError","text":"<pre><code>LiquidSyntaxError(\n*args: object,\nlinenum: Optional[int] = None,\nfilename: Optional[Union[str, Path]] = None\n)\n</code></pre> <p>         Bases: <code>Error</code></p> <p>Exception raised when there is a parser error.</p>"},{"location":"exceptions/#liquid.exceptions.LiquidTypeError","title":"LiquidTypeError","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when an error occurs at render time.</p>"},{"location":"exceptions/#liquid.exceptions.LiquidValueError","title":"LiquidValueError","text":"<p>         Bases: <code>LiquidSyntaxError</code></p> <p>Exception raised when a cast from str to int exceeds the length limit.</p>"},{"location":"exceptions/#liquid.exceptions.DisabledTagError","title":"DisabledTagError","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when an attempt is made to render a disabled tag.</p>"},{"location":"exceptions/#liquid.exceptions.NoSuchFilterFunc","title":"NoSuchFilterFunc","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when a filter lookup fails.</p>"},{"location":"exceptions/#liquid.exceptions.FilterArgumentError","title":"FilterArgumentError","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when a filter's arguments are invalid.</p>"},{"location":"exceptions/#liquid.exceptions.FilterValueError","title":"FilterValueError","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when a filters value is invalid.</p>"},{"location":"exceptions/#liquid.exceptions.TemplateNotFound","title":"TemplateNotFound","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when a template could not be found.</p>"},{"location":"exceptions/#liquid.exceptions.TemplateTraversalError","title":"TemplateTraversalError","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised when an AST node or expression can not be visited.</p>"},{"location":"exceptions/#liquid.exceptions.ContextDepthError","title":"ContextDepthError","text":"<p>         Bases: <code>ResourceLimitError</code></p> <p>Exception raised when the maximum context depth is reached.</p> <p>Usually indicates recursive use of <code>render</code> or <code>include</code> tags.</p>"},{"location":"exceptions/#liquid.exceptions.LocalNamespaceLimitError","title":"LocalNamespaceLimitError","text":"<p>         Bases: <code>ResourceLimitError</code></p> <p>Exception raised when a local namespace limit has been exceeded.</p>"},{"location":"exceptions/#liquid.exceptions.LoopIterationLimitError","title":"LoopIterationLimitError","text":"<p>         Bases: <code>ResourceLimitError</code></p> <p>Exception raised when the loop iteration limit has been exceeded.</p>"},{"location":"exceptions/#liquid.exceptions.OutputStreamLimitError","title":"OutputStreamLimitError","text":"<p>         Bases: <code>ResourceLimitError</code></p> <p>Exception raised when an output stream limit has been exceeded.</p>"},{"location":"exceptions/#liquid.exceptions.UndefinedError","title":"UndefinedError","text":"<p>         Bases: <code>Error</code></p> <p>Exception raised by the StrictUndefined type.</p>"},{"location":"loaders/","title":"Template Loaders","text":""},{"location":"loaders/#liquid.loaders.FileSystemLoader","title":"FileSystemLoader","text":"<pre><code>FileSystemLoader(\nsearch_path: Union[\nstr, Path, Iterable[Union[str, Path]]\n],\nencoding: str = \"utf-8\",\n)\n</code></pre> <p>         Bases: <code>BaseLoader</code></p> <p>A loader that loads templates from one or more directories on the file system.</p> PARAMETER DESCRIPTION <code>search_path</code> <p>One or more paths to search.</p> <p> TYPE: <code>Union[str, Path, Iterable[Union[str, Path]]]</code> </p> <code>encoding</code> <p>Open template files with the given encoding.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p>"},{"location":"loaders/#liquid.loaders.FileSystemLoader.resolve_path","title":"resolve_path","text":"<pre><code>resolve_path(template_name: str) -&gt; Path\n</code></pre> <p>Return a path to the template <code>template_name</code>.</p> <p>If the search path is a list of paths, returns the first path where <code>template_name</code> exists. If none of the search paths contain <code>template_name</code>, a <code>TemplateNotFound</code> exception is raised.</p>"},{"location":"loaders/#liquid.loaders.FileExtensionLoader","title":"FileExtensionLoader","text":"<pre><code>FileExtensionLoader(\nsearch_path: Union[\nstr, Path, Iterable[Union[str, Path]]\n],\nencoding: str = \"utf-8\",\next: str = \".liquid\",\n)\n</code></pre> <p>         Bases: <code>FileSystemLoader</code></p> <p>A file system loader that adds a file name extension if one is missing.</p> <p>: Args:     search_path: One or more paths to search.     encoding: Open template files with the given encoding.     ext: A default file extension. Should include a leading period.</p>"},{"location":"loaders/#liquid.loaders.DictLoader","title":"DictLoader","text":"<pre><code>DictLoader(templates: Dict[str, str])\n</code></pre> <p>         Bases: <code>BaseLoader</code></p> <p>A loader that loads templates from a dictionary.</p> PARAMETER DESCRIPTION <code>templates</code> <p>A dictionary mapping template names to template source strings.</p> <p> TYPE: <code>Dict[str, str]</code> </p>"},{"location":"loaders/#liquid.loaders.ChoiceLoader","title":"ChoiceLoader","text":"<pre><code>ChoiceLoader(loaders: List[BaseLoader])\n</code></pre> <p>         Bases: <code>BaseLoader</code></p> <p>A template loader that will try each of a list of loaders in turn.</p> PARAMETER DESCRIPTION <code>loaders</code> <p>A list of loaders implementing <code>liquid.loaders.BaseLoader</code>.</p> <p> TYPE: <code>List[BaseLoader]</code> </p>"},{"location":"loaders/#liquid.loaders.BaseLoader","title":"BaseLoader","text":"<p>         Bases: <code>ABC</code></p> <p>Base template loader from which all template loaders are derived.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.get_source","title":"get_source","text":"<pre><code>get_source(\nenv: Environment, template_name: str\n) -&gt; TemplateSource\n</code></pre> <p>Get the template source, filename and reload helper for a template.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>Environment</code> attempting to load the template source text.</p> <p> TYPE: <code>Environment</code> </p> <code>template_name</code> <p>A name or identifier for a template's source text.</p> <p> TYPE: <code>str</code> </p>"},{"location":"loaders/#liquid.loaders.BaseLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\nenv: Environment, template_name: str\n) -&gt; TemplateSource\n</code></pre> <p>An async version of <code>get_source</code>.</p> <p>The default implementation delegates to <code>get_source()</code>.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.get_source_with_args","title":"get_source_with_args","text":"<pre><code>get_source_with_args(\nenv: Environment, template_name: str, **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get template source text, optionally referencing arbitrary keyword arguments.</p> <p>Keyword arguments can be useful for multi-user environments where you need to modify a template loader's search space for a given user.</p> <p>By default, this method delegates to <code>get_source</code>, ignoring any keyword arguments.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.get_source_with_args_async","title":"get_source_with_args_async  <code>async</code>","text":"<pre><code>get_source_with_args_async(\nenv: Environment, template_name: str, **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>An async version of <code>get_source_with_args</code>.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.get_source_with_context","title":"get_source_with_context","text":"<pre><code>get_source_with_context(\ncontext: Context, template_name: str, **kwargs: str\n) -&gt; TemplateSource\n</code></pre> <p>Get a template's source, optionally referencing a render context.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.get_source_with_context_async","title":"get_source_with_context_async  <code>async</code>","text":"<pre><code>get_source_with_context_async(\ncontext: Context, template_name: str, **kwargs: str\n) -&gt; TemplateSource\n</code></pre> <p>An async version of <code>get_source_with_context</code>.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.load","title":"load","text":"<pre><code>load(\nenv: Environment,\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>Load and parse a template.</p> <p>Used internally by <code>Environment</code> to load a template source. Delegates to <code>get_source</code>. A custom loaders would typically implement <code>get_source</code> rather than overriding <code>load</code>.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.load_async","title":"load_async  <code>async</code>","text":"<pre><code>load_async(\nenv: Environment,\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>load</code>.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.load_with_args","title":"load_with_args","text":"<pre><code>load_with_args(\nenv: Environment,\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n**kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>Load template source text, optionally referencing extra keyword arguments.</p> <p>Most custom loaders will want to override <code>get_source_with_args()</code> rather than this method. For example, you might want to override <code>load_with_args()</code> and <code>get_source_with_args()</code> when implementing a custom caching loader. Where cache handling happens in <code>load_*</code> methods.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.load_with_args_async","title":"load_with_args_async  <code>async</code>","text":"<pre><code>load_with_args_async(\nenv: Environment,\nname: str,\nglobals: Optional[Mapping[str, object]] = None,\n**kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>load_with_args()</code>.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.load_with_context","title":"load_with_context","text":"<pre><code>load_with_context(\ncontext: Context, name: str, **kwargs: str\n) -&gt; BoundTemplate\n</code></pre> <p>Load and parse a template, optionally referencing a render context.</p>"},{"location":"loaders/#liquid.loaders.BaseLoader.load_with_context_async","title":"load_with_context_async  <code>async</code>","text":"<pre><code>load_with_context_async(\ncontext: Context, name: str, **kwargs: str\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>load_with_context</code>.</p>"},{"location":"loaders/#liquid.loaders.TemplateSource","title":"TemplateSource","text":"<p>         Bases: <code>NamedTuple</code></p> <p>A Liquid template source as returned by the <code>get_source</code> method of a <code>loader</code>.</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>The liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>filename</code> <p>The liquid template file name or other string identifying its origin.</p> <p> TYPE: <code>str</code> </p> <code>uptodate</code> <p>Optional callable that will return <code>True</code> if the template is up to date, or <code>False</code> if it needs to be reloaded.</p> <p> TYPE: <code>UpToDate</code> </p> <code>matter</code> <p>Optional mapping containing variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> </p>"},{"location":"undefined/","title":"Undefined Types","text":""},{"location":"undefined/#liquid.Undefined","title":"Undefined","text":"<pre><code>Undefined(\nname: str,\nobj: object = UNDEFINED,\nhint: Optional[str] = None,\n)\n</code></pre> <p>         Bases: <code>Mapping[Any, object]</code></p> <p>The default undefined type.</p> <p>Always evaluates to an empty string. Can be iterated over and indexed without error.</p>"},{"location":"undefined/#liquid.StrictUndefined","title":"StrictUndefined","text":"<pre><code>StrictUndefined(\nname: str,\nobj: object = UNDEFINED,\nhint: Optional[str] = None,\n)\n</code></pre> <p>         Bases: <code>Undefined</code></p> <p>An undefined that raises an exception for everything other than <code>repr</code>.</p>"},{"location":"undefined/#liquid.DebugUndefined","title":"DebugUndefined","text":"<p>         Bases: <code>Undefined</code></p> <p>An undefined that returns debug information when rendered.</p>"},{"location":"undefined/#liquid.StrictDefaultUndefined","title":"StrictDefaultUndefined","text":"<p>         Bases: <code>StrictUndefined</code></p> <p>An undefined that plays nicely with the <code>default</code> filter.</p>"}]}